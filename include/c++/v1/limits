#ifndef _METALLIC_LIMITS
#define _METALLIC_LIMITS

namespace std {

enum float_denorm_style
{
    denorm_indeterminate = -1,
    denorm_absent        =  0,
    denorm_present       =  1
};

enum float_round_style
{
    round_indeterminate       = -1,
    round_toward_zero         =  0,
    round_to_nearest          =  1,
    round_toward_infinity     =  2,
    round_toward_neg_infinity =  3
};

template<typename>
struct __limits_base;

template<typename _T>
struct numeric_limits
  : __limits_base<_T>
{};

template<typename _T>
struct __basic_limits
{
    static constexpr bool is_specialized = false;

    static constexpr bool is_signed = false;
    static constexpr bool is_integer = false;
    static constexpr bool is_exact = false;

    static constexpr bool has_infinity = false;
    static constexpr bool has_quiet_NaN = false;
    static constexpr bool has_signaling_NaN = false;

    static constexpr float_denorm_style has_denorm = denorm_absent;
    static constexpr bool has_denorm_loss = false;

    static constexpr float_round_style round_style = round_toward_zero;

    static constexpr bool is_iec559 = false;
    static constexpr bool is_bounded = false;
    static constexpr bool is_modulo = false;

    static constexpr int digits = 0;
    static constexpr int digits10 = 0;
    static constexpr int max_digits10 = 0;

    static constexpr int radix = 0;

    static constexpr int min_exponent = 0;
    static constexpr int min_exponent10 = 0;
    static constexpr int max_exponent = 0;
    static constexpr int max_exponent10 = 0;

    static constexpr bool traps = false;
    static constexpr bool tinyness_before = false;

    static constexpr _T min() noexcept
    {
        return _T();
    }

    static constexpr _T lowest() noexcept
    {
        return _T();
    }

    static constexpr _T max() noexcept
    {
        return _T();
    }

    static constexpr _T epsilon() noexcept
    {
        return _T();
    }

    static constexpr _T round_error() noexcept
    {
        return _T();
    }

    static constexpr _T infinity() noexcept
    {
        return _T();
    }

    static constexpr _T quiet_NaN() noexcept
    {
        return _T();
    }

    static constexpr _T signaling_NaN() noexcept
    {
        return _T();
    }

    static constexpr _T denorm_min() noexcept
    {
        return _T();
    }
};

template<typename _T, _T __x, bool = (__x > 0)>
struct __meta_fls
{
    static constexpr int value = __meta_fls<_T, (__x >> 1)>::value + 1;
};

template<typename _T, _T __x>
struct __meta_fls<_T, __x, false>
{
    static constexpr int value = 0;
};

template<typename _T>
struct __integral_limits
  : __basic_limits<_T>
{
    static constexpr bool is_specialized = true;

    static constexpr bool is_signed = _T(-1) < 0;
    static constexpr bool is_integer = true;
    static constexpr bool is_exact = true;

    static constexpr bool is_bounded = true;
    static constexpr bool is_modulo = !is_signed;

    static constexpr int digits = __meta_fls<_T, -1>::value;
    static constexpr int digits10 = digits * 1642637L / 5456722;

    static constexpr int radix = 2;

    static constexpr bool traps = _T(2) == 2;

    static constexpr _T min() noexcept
    {
        return is_signed * (-numeric_limits<_T>::max() - !~_T(-1));
    }

    static constexpr _T lowest() noexcept
    {
        return numeric_limits<_T>::min();
    }

    static constexpr _T max() noexcept
    {
        return -1;
    }
};

template<typename _T>
struct __float_limits
  : __basic_limits<_T>
{
    static constexpr bool is_specialized = true;
    static constexpr bool is_signed = true;

    static constexpr float_round_style round_style = round_to_nearest;

    static constexpr bool is_bounded = true;

    static constexpr int radix = __FLT_RADIX__;

    static constexpr _T round_error() noexcept
    {
        return 0.5;
    }

    static constexpr _T lowest() noexcept
    {
        return -numeric_limits<_T>::max();
    }
};

template<typename _T>
struct __limits_base
  : __basic_limits<_T>
{};

template<typename _T>
struct __limits_base<const _T>
  : __limits_base<_T>
{};

template<typename _T>
struct __limits_base<volatile _T>
  : __limits_base<_T>
{};

template<typename _T>
struct __limits_base<const volatile _T>
  : __limits_base<_T>
{};

template<>
struct __limits_base<bool>
  : __integral_limits<bool>
{};

template<>
struct __limits_base<unsigned char>
  : __integral_limits<unsigned char>
{};

template<>
struct __limits_base<char16_t>
  : __integral_limits<char16_t>
{};

template<>
struct __limits_base<char32_t>
  : __integral_limits<char32_t>
{};

template<>
struct __limits_base<unsigned short>
  : __integral_limits<unsigned short>
{};

template<>
struct __limits_base<unsigned>
  : __integral_limits<unsigned>
{};

template<>
struct __limits_base<unsigned long>
  : __integral_limits<unsigned long>
{};

__extension__
template<>
struct __limits_base<unsigned long long>
  : __integral_limits<unsigned long long>
{};

template<>
struct __limits_base<signed char>
  : __integral_limits<signed char>
{
    static constexpr int digits = __meta_fls<signed char, __SCHAR_MAX__>::value;
    static constexpr int digits10 = digits * 1642637L / 5456722;

    static constexpr signed char max() noexcept
    {
        return __SCHAR_MAX__;
    }
};

template<>
struct __limits_base<char>
  : __integral_limits<char>
{
    static constexpr int digits = __meta_fls<
        char,
        is_signed ? __SCHAR_MAX__ : -1
    >::value;

    static constexpr int digits10 = digits * 1642637L / 5456722;

    static constexpr char max() noexcept
    {
        return is_signed ? numeric_limits<signed char>::max() : -1;
    }
};

template<>
struct __limits_base<short>
  : __integral_limits<short>
{
    static constexpr int digits = __meta_fls<short, __SHRT_MAX__>::value;
    static constexpr int digits10 = digits * 1642637L / 5456722;

    static constexpr short max() noexcept
    {
        return __SHRT_MAX__;
    }
};

template<>
struct __limits_base<int>
  : __integral_limits<int>
{
    static constexpr int digits = __meta_fls<int, __INT_MAX__>::value;
    static constexpr int digits10 = digits * 1642637L / 5456722;

    static constexpr int max() noexcept
    {
        return __INT_MAX__;
    }
};

template<>
struct __limits_base<long>
  : __integral_limits<long>
{
    static constexpr int digits = __meta_fls<long, __LONG_MAX__>::value;
    static constexpr int digits10 = digits * 1642637L / 5456722;

    static constexpr long max() noexcept
    {
        return __LONG_MAX__;
    }
};

__extension__
template<>
struct __limits_base<long long>
  : __integral_limits<long long>
{
    static constexpr int digits = __meta_fls<long long, __LONG_LONG_MAX__>::value;
    static constexpr int digits10 = digits * 1642637L / 5456722;

    static constexpr long long max() noexcept
    {
        return __LONG_LONG_MAX__;
    }
};

template<>
struct __limits_base<wchar_t>
  : __limits_base<__WCHAR_TYPE__>
{};

template<>
struct __limits_base<float>
  : __float_limits<float>
{
    static constexpr bool has_infinity = __FLT_HAS_INFINITY__;
    static constexpr bool has_quiet_NaN = __FLT_HAS_QUIET_NAN__;
    static constexpr bool has_signaling_NaN = has_quiet_NaN;

    static constexpr float_denorm_style has_denorm = float_denorm_style(__FLT_HAS_DENORM__);

    static constexpr int digits = __FLT_MANT_DIG__;
    static constexpr int digits10 = __FLT_DIG__;
    static constexpr int max_digits10 = 0.30102999566398119521 * digits + 2;

    static constexpr int min_exponent = __FLT_MIN_EXP__;
    static constexpr int min_exponent10 = __FLT_MIN_10_EXP__;
    static constexpr int max_exponent = __FLT_MAX_EXP__;
    static constexpr int max_exponent10 = __FLT_MAX_10_EXP__;

    static constexpr bool is_iec559 =
        is_signed && has_infinity && has_quiet_NaN &&
        has_denorm == denorm_present &&
        (radix == 2 || radix == 10) &&
        min_exponent + max_exponent == 1;

    static constexpr float min() noexcept
    {
        return __FLT_MIN__;
    }

    static constexpr float max() noexcept
    {
        return __FLT_MAX__;
    }

    static constexpr float epsilon() noexcept
    {
        return __FLT_EPSILON__;
    }

    static constexpr float infinity() noexcept
    {
        return __builtin_huge_valf();
    }

    static constexpr float quiet_NaN() noexcept
    {
        return  __builtin_nanf("");
    }

    static constexpr float signaling_NaN() noexcept
    {
        return __builtin_nansf("");
    }

    static constexpr float denorm_min() noexcept
    {
        return __FLT_DENORM_MIN__;
    }
};

template<>
struct __limits_base<double>
  : __float_limits<double>
{
    static constexpr bool has_infinity = __DBL_HAS_INFINITY__;
    static constexpr bool has_quiet_NaN = __DBL_HAS_QUIET_NAN__;
    static constexpr bool has_signaling_NaN = has_quiet_NaN;

    static constexpr float_denorm_style has_denorm = float_denorm_style(__DBL_HAS_DENORM__);

    static constexpr int digits = __DBL_MANT_DIG__;
    static constexpr int digits10 = __DBL_DIG__;
    static constexpr int max_digits10 = 0.30102999566398119521 * digits + 2;

    static constexpr int min_exponent = __DBL_MIN_EXP__;
    static constexpr int min_exponent10 = __DBL_MIN_10_EXP__;
    static constexpr int max_exponent = __DBL_MAX_EXP__;
    static constexpr int max_exponent10 = __DBL_MAX_10_EXP__;

    static constexpr bool is_iec559 =
        is_signed && has_infinity && has_quiet_NaN &&
        has_denorm == denorm_present &&
        (radix == 2 || radix == 10) &&
        min_exponent + max_exponent == 1;

    static constexpr double min() noexcept
    {
        return __DBL_MIN__;
    }

    static constexpr double max() noexcept
    {
        return __DBL_MAX__;
    }

    static constexpr double epsilon() noexcept
    {
        return __DBL_EPSILON__;
    }

    static constexpr double infinity() noexcept
    {
        return __builtin_huge_val();
    }

    static constexpr double quiet_NaN() noexcept
    {
        return  __builtin_nan("");
    }

    static constexpr double signaling_NaN() noexcept
    {
        return __builtin_nans("");
    }

    static constexpr double denorm_min() noexcept
    {
        return __DBL_DENORM_MIN__;
    }
};

template<>
struct __limits_base<long double>
  : __float_limits<long double>
{
    static constexpr bool has_infinity = __LDBL_HAS_INFINITY__;
    static constexpr bool has_quiet_NaN = __LDBL_HAS_QUIET_NAN__;
    static constexpr bool has_signaling_NaN = has_quiet_NaN;

    static constexpr float_denorm_style has_denorm = float_denorm_style(__LDBL_HAS_DENORM__);

    static constexpr int digits = __LDBL_MANT_DIG__;
    static constexpr int digits10 = __LDBL_DIG__;
    static constexpr int max_digits10 = 0.30102999566398119521 * digits + 2;

    static constexpr int min_exponent = __LDBL_MIN_EXP__;
    static constexpr int min_exponent10 = __LDBL_MIN_10_EXP__;
    static constexpr int max_exponent = __LDBL_MAX_EXP__;
    static constexpr int max_exponent10 = __LDBL_MAX_10_EXP__;

    static constexpr bool is_iec559 =
        is_signed && has_infinity && has_quiet_NaN &&
        has_denorm == denorm_present &&
        (radix == 2 || radix == 10) &&
        min_exponent + max_exponent == 1;

    static constexpr long double min() noexcept
    {
        return __LDBL_MIN__;
    }

    static constexpr long double max() noexcept
    {
        return __LDBL_MAX__;
    }

    static constexpr long double epsilon() noexcept
    {
        return __LDBL_EPSILON__;
    }

    static constexpr long double infinity() noexcept
    {
        return __builtin_huge_vall();
    }

    static constexpr long double quiet_NaN() noexcept
    {
        return  __builtin_nanl("");
    }

    static constexpr long double signaling_NaN() noexcept
    {
        return __builtin_nansl("");
    }

    static constexpr long double denorm_min() noexcept
    {
        return __LDBL_DENORM_MIN__;
    }
};

} // std

#endif // <limits>

// vim: ft=cpp
