#ifndef _METALLIC_UTILITY
#define _METALLIC_UTILITY

#include <initializer_list>
#include <type_traits>

namespace std {

template<typename _T>
__enable_if_t<is_move_constructible<_T>::value && is_move_assignable<_T>::value>
swap(_T& __x, _T& __y) noexcept(is_nothrow_move_constructible<_T>::value && is_nothrow_move_assignable<_T>::value)
{
    _T __t = static_cast<_T&&>(__x);
    __x = static_cast<_T&&>(__y);
    __y = static_cast<_T&&>(__t);
}

template<typename _T, size_t _N>
__enable_if_t<__swappable<_T>::value>
swap(_T (&__x)[_N], _T (&__y)[_N]) noexcept(__nothrow_swappable<_T>::value)
{
    for (size_t __i = 0; __i < _N; ++__i)
        swap(__x[__i], __y[__i]);
}

template<typename _T>
constexpr _T&& forward(__remove_reference_t<_T>& __x) noexcept
{
    return static_cast<_T&&>(__x);
}

template<typename _T>
constexpr _T&& forward(__remove_reference_t<_T>&& __x) noexcept
{
    static_assert(!is_lvalue_reference<_T>::value, "It is prohibited to forward rvalues as lvalues.");
    return static_cast<_T&&>(__x);
}

template<typename _T>
constexpr __remove_reference_t<_T>&& move(_T&& __x) noexcept
{
    return static_cast<__remove_reference_t<_T>&&>(__x);
}

template<typename _T>
typename conditional<!is_nothrow_move_constructible<_T>::value && is_copy_constructible<_T>::value, const _T&, _T&&>::type
move_if_noexcept(_T& __x) noexcept
{
    return static_cast<_T&&>(__x);
}

struct piecewise_construct_t
{
#if __cplusplus > 201402L
    explicit piecewise_construct_t() = default;
#endif
};

#if __cplusplus > 201402L
inline
#endif
constexpr piecewise_construct_t piecewise_construct {};

#if __cplusplus > 201103L

template<typename _T, typename _U = _T>
_T exchange(_T& __reference, _U&& __value)
{
    _T __result = static_cast<_T&&>(__reference);
    __reference = static_cast<_U&&>(__value);
    return __result;
}

#endif // C++ > 11

#if __cplusplus > 201402L

template<typename _T>
constexpr const _T& as_const(_T& __x) noexcept
{
    return __x;
}

template<typename _T>
void as_const(const _T&&) = delete;

struct in_place_t
{
    explicit in_place_t() = default;
};

template<typename>
struct in_place_type_t
{
    explicit in_place_type_t() = default;
};

template<size_t>
struct in_place_index_t
{
    explicit in_place_index_t() = default;
};

inline constexpr in_place_t in_place {};

template <class _T>
inline constexpr in_place_type_t<_T> in_place_type {};

template <size_t _I>
inline constexpr in_place_index_t<_I> in_place_index {};

#endif // C++ > 14

} // std

#endif // <utility>

// vim: ft=cpp
