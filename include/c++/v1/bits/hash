#ifndef _METALLIC_BITS_HASH
#define _METALLIC_BITS_HASH

#include <bits/attributes>
#include <limits>
#include <type_traits>

namespace std {

typedef decltype(sizeof(0)) size_t;

static_assert(numeric_limits<size_t>::digits == sizeof(size_t) * numeric_limits<unsigned char>::digits,
    "size_t with padding bits is unsupported");

template<typename _T>
struct __hash_base
{
    _METALLIC_DEPRECATED typedef _T argument_type;
    _METALLIC_DEPRECATED typedef size_t result_type;
};

template<typename _T>
struct __poisoned_hash : __hash_base<_T>
{
    __poisoned_hash() = delete;
    __poisoned_hash(__poisoned_hash&&) = delete;
    __poisoned_hash& operator=(__poisoned_hash&&) = delete;
};

constexpr size_t __serial_xor(const size_t (&__x)[1])
{
    return *__x;
}

constexpr size_t __serial_xor(const size_t (&__x)[2])
{
    return __x[0] ^ __x[1];
}

constexpr size_t __serial_xor(const size_t (&__x)[3])
{
    return __x[0] ^ __x[1] ^ __x[2];
}

constexpr size_t __serial_xor(const size_t (&__x)[4])
{
    return __x[0] ^ __x[1] ^ __x[2] ^ __x[3];
}

template<size_t _N>
size_t __serial_xor(const size_t (&__x)[_N])
{
    auto __y = reinterpret_cast<const size_t (*)[_N >> 1]>(__x + (_N & 1));
    return (_N & 1) * __x[0] ^ __serial_xor(__y[0]) ^ __serial_xor(__y[1]);
}

template<typename _T, bool _Aligned, size_t _N = sizeof(_T) / sizeof(size_t) + (!_Aligned && sizeof(_T) % sizeof(size_t))>
struct __xor_hash;

template<typename _T>
struct __xor_hash<_T, false, 1> : __hash_base<_T>
{
    size_t operator()(_T __t) const noexcept
    {
        union { _T __x; size_t __y = 0; };
        __x = __t;
        return __y;
    }
};

template<typename _T, size_t _N>
struct __xor_hash<_T, false, _N> : __hash_base<_T>
{
    size_t operator()(_T __t) const noexcept
    {
        union { _T __x; size_t __y[_N] = {}; };
        __x = __t;
        return __serial_xor(__y);
    }
};

template<typename _T>
struct __xor_hash<_T, true, 0> : __xor_hash<_T, false, 1>
{};

template<typename _T>
struct __xor_hash<_T, true, 1> : __hash_base<_T>
{
    size_t operator()(_T __t) const noexcept
    {
        union { _T __x; size_t __y; };
        __x = __t;
        return __y;
    }
};

template<typename _T, size_t _N>
struct __xor_hash<_T, true, _N> : __hash_base<_T>
{
    size_t operator()(_T __t) const noexcept
    {
        union { _T __x; size_t __y[_N]; };
        __x = __t;
        return __serial_xor(__y);
    }
};

template<typename _T>
struct __identity_hash : __hash_base<_T>
{
    size_t operator()(_T __x) const noexcept { return __x; }
};

template<typename _T>
using __longint_hash = __xor_hash<_T,
    !(numeric_limits<_T>::digits + numeric_limits<_T>::is_signed) % numeric_limits<size_t>::digits>;

template<typename> struct hash;

template<> struct hash<bool> : __identity_hash<bool> {};
template<> struct hash<char> : __identity_hash<char> {};
template<> struct hash<signed char> : __identity_hash<signed char> {};
template<> struct hash<unsigned char> : __identity_hash<unsigned char> {};
template<> struct hash<char16_t> : __identity_hash<char16_t> {};
template<> struct hash<char32_t> : __identity_hash<char32_t> {};
template<> struct hash<wchar_t> : __identity_hash<wchar_t> {};
template<> struct hash<short> : __identity_hash<short> {};
template<> struct hash<unsigned short> : __identity_hash<unsigned short> {};
template<> struct hash<int> : __identity_hash<int> {};
template<> struct hash<unsigned> : __identity_hash<unsigned> {};
template<> struct hash<long> : __identity_hash<long> {};
template<> struct hash<unsigned long> : __identity_hash<unsigned long> {};

#if __cplulsplus > 201703L
template<> struct hash<char8_t> : __identity_hash<char8_t> {};
#endif

template<> struct hash<long long> : __longint_hash<long long> {};
template<> struct hash<unsigned long long> : __longint_hash<unsigned long long> {};
#ifdef __SIZEOF_INT128__
template<> struct hash<__int128> : __longint_hash<__int128> {};
template<> struct hash<unsigned __int128> : __longint_hash<unsigned __int128> {};
#endif

template<typename _T>
class __fp_hash
{
    template<int _N>
    struct _IsPowerOf2
      : integral_constant<bool, !(_N & (_N - 1))>
    {};

public:
    size_t operator()(_T __t) const noexcept
    {
        const bool __aligned = numeric_limits<_T>::is_iec559 &&
            !_IsPowerOf2<numeric_limits<_T>::digits>::value &&
            _IsPowerOf2<numeric_limits<size_t>::digits>::value;

        return __t ? __xor_hash<_T, __aligned>()(__t) : 0;
    }
};

template<> struct hash<float> : __fp_hash<float> {};
template<> struct hash<double> : __fp_hash<double> {};
template<> struct hash<long double> : __fp_hash<long double> {};
#ifdef __SIZEOF_FLOAT128__
template<> struct hash<__float128> : __fp_hash<__float128> {};
#endif

template<> struct hash<decltype(nullptr)> : __hash_base<decltype(nullptr)>
{
    size_t operator()(decltype(nullptr)) const noexcept { return 0; }
};

template<typename _T>
struct hash<_T*> : __hash_base<_T*>
{
    size_t operator()(_T* __x) const noexcept { return reinterpret_cast<size_t>(__x); }
};

template<typename _T, bool = is_enum<_T>::value>
struct __enum_hash : __hash_base<_T>
{
    size_t operator()(_T __x) const noexcept
    {
        typedef typename underlying_type<_T>::type _U;
        return hash<_U>()(static_cast<_U>(__x));
    }
};

template<typename _T>
struct __enum_hash<_T, false> : __poisoned_hash<_T>
{};

template<typename _T>
struct hash : __enum_hash<_T>
{};

} // std

#endif // <bits/hash>

// vim: ft=cpp
